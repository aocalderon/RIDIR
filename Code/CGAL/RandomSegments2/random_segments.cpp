#include <CGAL/Cartesian.h>
#include <CGAL/Quotient.h>
#include <CGAL/MP_Float.h>
#include <CGAL/Arr_segment_traits_2.h>
#include <CGAL/Arrangement_2.h>
#include <CGAL/Arr_naive_point_location.h>
#include <CGAL/Arr_landmarks_point_location.h>
#include <CGAL/IO/WKT.h>

#include <random>

#include "arr_print.h"

typedef CGAL::Quotient<CGAL::MP_Float>                    Number_type;
typedef CGAL::Cartesian<Number_type>                      Kernel;
typedef CGAL::Arr_segment_traits_2<Kernel>                Traits_2;
typedef Traits_2::Point_2                                 Point_2;
typedef Traits_2::X_monotone_curve_2                      Segment_2;
typedef CGAL::Arrangement_2<Traits_2>                     Arrangement_2;
typedef CGAL::Arr_landmarks_point_location<Arrangement_2> Landmarks_pl;

// Function to generate uniformly random double values between [0.0 - 1.0)...
double doubleRand() {
  return double(rand()) / (double(RAND_MAX) + 1.0);
}

int main (int argc, char* argv[]){
  // Setting variables...
  int z = 0; 
  int n = 0; 
  int c;
  while ((c = getopt (argc, argv, "n:z:")) != -1){
    switch (c){
      case 'z':
	if(optarg) z = std::atoi(optarg); // Getting width and height for study area...
        break;
      case 'n':
	if(optarg) n = std::atoi(optarg); // Getting number of segments...
        break;
      case '?':
        return 1;
      default:
	abort ();
    }
  }
  Segment_2 segment;
  Arrangement_2 arr;
  Landmarks_pl landmark_pl (arr);
  landmark_pl.attach(arr);

  std::random_device seed;  // Will be used to obtain a seed for the random number engine...
  std::mt19937 generator(seed()); // Standard mersenne_twister_engine seeded with seed()...
  std::uniform_real_distribution<> d(0, z); // The uniform distribution...

  // Inserting edges...
  std::cout << "Inserting edges..." << std::endl;
  for (int i = 0; i < n; ++i) {
    // Use d to transform the random unsigned int generated by generator into a 
    // double in [0, z). Each call to d(generator) generates a new random double...
    
    segment = Segment_2 ( Point_2(d(generator), d(generator)), Point_2(d(generator), d(generator)));
    
    insert(arr, segment, landmark_pl);
  }
  std::cout << "Done! " << n << " edges has been inserted." << std::endl;
  
  // Printing arrangement info...
  std::cout << "The arrangement size:" << std::endl
            << "   V = " << arr.number_of_vertices()
            << ",  E = " << arr.number_of_edges() 
            << ",  F = " << arr.number_of_faces() << std::endl;
  
  return 0;
}
