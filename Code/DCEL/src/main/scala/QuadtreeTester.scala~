import org.slf4j.{LoggerFactory, Logger}
import org.rogach.scallop._
import org.apache.spark.sql.{SparkSession, Dataset}
import org.apache.spark.rdd.RDD
import org.apache.spark.serializer.KryoSerializer
import org.apache.spark.storage.StorageLevel
import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.sql.functions._
import org.datasyslab.geospark.enums.{FileDataSplitter, GridType, IndexType}
import org.datasyslab.geospark.spatialPartitioning.quadtree._
import org.datasyslab.geospark.spatialRDD.{SpatialRDD, PolygonRDD, LineStringRDD}
import org.datasyslab.geospark.serde.GeoSparkKryoRegistrator
import com.vividsolutions.jts.geom.{GeometryFactory, PrecisionModel}
import com.vividsolutions.jts.geom.{Geometry, Envelope, Coordinate,  Polygon, LinearRing, LineString, MultiPolygon, Point}
import com.vividsolutions.jts.geom.impl.CoordinateArraySequence
import com.vividsolutions.jts.algorithm.{RobustCGAlgorithms, CGAlgorithms}
import com.vividsolutions.jts.io.WKTReader
import org.geotools.geometry.jts.GeometryClipper
import scala.collection.JavaConverters._
import scala.collection.mutable.{ListBuffer, TreeSet, ArrayBuffer, HashSet}

val precisionModel = new PrecisionModel(math.pow(10, 3))
val geofactory = new GeometryFactory(precisionModel)

// Reading data...
val input = "/home/acald013/Datasets/CA/cali2000_polygons6414.tsv"
val offset = 2
val quote = true
val polygonRDD = new SpatialRDD[Polygon]()
val polygons = spark.read.textFile(input).repartition(200).rdd.zipWithUniqueId().map{ case (line, i) =>
  val arr = line.split("\t")
  val userData = List(s"$i") ++ (0 until arr.size).filter(_ != offset).map(i => arr(i))
  var wkt = arr(offset)
  if(quote){
    wkt = wkt.replaceAll("\"", "")
  }
  val polygon = new WKTReader(geofactory).read(wkt)
  polygon.setUserData(userData.mkString("\t"))
  polygon.asInstanceOf[Polygon]
}.cache
polygonRDD.setRawSpatialRDD(polygons)
polygonRDD.analyze()

// Partition edges...
def getRings(polygon: Polygon): List[Array[Coordinate]] = {
  var exteriorCoords = polygon.getExteriorRing.getCoordinateSequence.toCoordinateArray()
  if(!CGAlgorithms.isCCW(exteriorCoords)) { exteriorCoords = exteriorCoords.reverse }
  val outerRing = List(exteriorCoords)

  val nInteriorRings = polygon.getNumInteriorRing
  val innerRings = (0 until nInteriorRings).map{ i =>
    var interiorCoords = polygon.getInteriorRingN(i).getCoordinateSequence.toCoordinateArray()
    if(CGAlgorithms.isCCW(interiorCoords)) { interiorCoords = interiorCoords.reverse }
    interiorCoords
  }.toList

  outerRing ++ innerRings
}

def getHalf_edges(polygon: Polygon): List[LineString] = {
  val polygon_id = polygon.getUserData.toString().split("\t")(0)
  val rings = getRings(polygon).zipWithIndex
  val hasHoles = rings.size > 1 match {
    case true => 1
    case _    => 0
  }
  rings.flatMap{ ring =>
    val ring_id = ring._2
    ring._1.zip(ring._1.tail).zipWithIndex.map{ pair =>
      val order = pair._2
      val coord1 = pair._1._1
      val coord2 = pair._1._2
      val coords = new CoordinateArraySequence(Array(coord1, coord2))

      val line = geofactory.createLineString(coords)
      line.setUserData(s"${polygon_id}\t${ring_id}\t${order}\t${hasHoles}")

      line
    }
  }
}

val edges = polygons.map(_.asInstanceOf[Polygon]).flatMap(getHalf_edges).cache
val nEdges = edges.count()

val edgesRDD = new SpatialRDD[LineString]()
edgesRDD.setRawSpatialRDD(edges)
edgesRDD.analyze()
val entries = 200
val levels = 8
val boundary = new QuadRectangle(edgesRDD.boundaryEnvelope)
val quadtree = new StandardQuadTree[LineString](boundary, 0, entries, levels)
for(edge <- edges.sample(false, params.esample(), 42).collect()) {
  quadtree.insert(new QuadRectangle(edge.getEnvelopeInternal), edge)
}
quadtree.assignPartitionIds()
quadtree.assignPartitionLineage()
val EdgePartitioner = new QuadTreePartitioner(quadtree)
edgesRDD.spatialPartitioning(EdgePartitioner)
edgesRDD.spatialPartitionedRDD.rdd.cache
val cells = quadtree.getLeafZones.asScala.map(c => c.partitionId -> c.getEnvelope).toMap

