
package edu.ucr.dblab.sdcel

import com.vividsolutions.jts.geom.LineString
import com.vividsolutions.jts.geom.{PrecisionModel, GeometryFactory}
import org.apache.spark.serializer.KryoSerializer
import org.apache.spark.sql.{SparkSession, SaveMode}
import org.apache.spark.TaskContext
import org.datasyslab.geospark.serde.GeoSparkKryoRegistrator
import org.slf4j.{Logger, LoggerFactory}

import PartitionReader.{readQuadtree, readEdges, envelope2polygon}
import edu.ucr.dblab.sdcel.SDCEL.{log, save}

object Info {
  implicit val logger: Logger = LoggerFactory.getLogger("myLogger")

  case class Settings(appId: String)

  def main(args: Array[String]) = {
    // Starting session...
    logger.info("Starting session...")
    implicit val params = new Params(args)
    val model = new PrecisionModel(params.scale())
    implicit val geofactory = new GeometryFactory(model)

    val (quadtree, cells) = readQuadtree[Int](params.quadtree(), params.boundary())
    save{"/tmp/edgesCells.wkt"}{
      cells.values.map{ cell =>
        val wkt = envelope2polygon(cell.mbr.getEnvelopeInternal).toText
        val id = cell.id
        val lineage = cell.lineage
        s"$wkt\t$id\t$lineage\n"
      }.toList
    }
    logger.info(s"Number of partitions: ${cells.size}")

    implicit val spark = SparkSession.builder()
        .config("spark.serializer",classOf[KryoSerializer].getName)
        .config("spark.kryo.registrator", classOf[GeoSparkKryoRegistrator].getName)
        .getOrCreate()
    import spark.implicits._
    val conf = spark.sparkContext.getConf
    val appId = conf.get("spark.app.id")
    implicit val settings = Settings(appId)
    val command = System.getProperty("sun.java.command")
    log(command)
    log("Starting session... Done!")

    // Reading data...
    val edgesRDDA = readEdges(params.input1(), quadtree, "A")
    //edgesRDDA.persist()
    //val nEdgesRDDA = edgesRDDA.count()
    //println("Edges A: " + nEdgesRDDA)

    val edgesRDDB = readEdges(params.input2(), quadtree, "B")
    //edgesRDDB.persist()
    //val nEdgesRDDB = edgesRDDB.count()
    //println("Edges B: " + nEdgesRDDB)

    log("Reading data... Done!")

    save{"/tmp/edgesGrids.wkt"}{
      edgesRDDA.zipPartitions(edgesRDDB, preservesPartitioning=true){ (iterA, iterB) =>
        val i = TaskContext.getPartitionId
        val cell = cells(i)
        val wkt = cell.wkt
        val centroid = cell.toPolygon.getCentroid
        val x = centroid.getX
        val y = centroid.getY
        val n = iterA.size + iterB.size
        Iterator(s"$wkt\t$x\t$y\t$n\n")
      }.collect
    }
  }
}
